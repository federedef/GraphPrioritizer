%statistics_ontology_profiles_[$nets]){
	source ~soft_bio_267/initializes/init_ruby 
	echo -e "(*)" > tracker
	ont_id=`grep -P '^(*)' $net2custom | cut -f 2`
	exec_mode=`grep -P '^(*)' $net2custom | cut -f 3`
	simil_code=`grep -P '^(*)' $net2custom | cut -f 4`
	?
	semtools.rb -i $input_path/input_processed/(*) -o ./results.txt -O $ont_id -n -S "," -c -T $simil_code > annotations_metrics
	if [ -s annotations_metrics ] ; then 
		awk -v tracker="`cat tracker`" 'BEGIN{FS="\t";OFS="\t"}{gsub(/ /,"_",$0); print tracker,$1,$2}' annotations_metrics >> ../annotations_metrics
	else
		exit 1
	fi
}

%calc_similarity_[$nets]){
	# Input: Tab file gen\tOnto_element1;Onto_element2;... + Archivo .obo
	# Output: Similarity binary Matrix + Metrics
	source ~soft_bio_267/initializes/init_ruby 
	#source ~josecordoba/software/initializes/init_semtools_script 
	source ~soft_bio_267/initializes/init_R

	echo -e "(*)_sim" > tracker
	similarity_path=`pwd`
	#net_id=`grep -P '^(*)' $net2custom | cut -f 1`
	ont_id=`grep -P '^(*)' $net2custom | cut -f 2`
	#exec_mode=`grep -P '^(*)' $net2custom | cut -f 3`
	simil_code=`grep -P '^(*)' $net2custom | cut -f 4`
	filter_factor=`grep -P '^(*)' $net2custom | cut -f 5`
	?
	semtools.rb -i $input_path/input_processed/(*) -o ./results.txt -O $ont_id -s lin -S "," -c -T $simil_code
	awk 'BEGIN{FS="\t";OFS="\t"}{if( $1 == $2 ) $3="0"; print $1,$2,$3}' (*)_semantic_similarity_list > semantic_similarity_list # Set diagonal to 0.
	text2binary_matrix.rb -i semantic_similarity_list -o semantic_matrix_bin -t pair -s > similarity_metrics # Obtain statistical metrics and pass to matrix bin.

	if [ -s similarity_metrics ] ; then 
		awk -v tracker="`cat tracker`" 'BEGIN{FS="\t";OFS="\t"}{gsub(/ - /,"_",$1); gsub(/ /,"_",$0); print tracker,$1,$2}' similarity_metrics >> ../similarity_metrics 
		#echo -e "(*)\t$similarity_path/semantic_matrix_bin" >> ../similarity_tracker
	else
		exit 1
	fi
	#TODO (Maybe): Add the next topic in the report section.
	if [ $filter_factor == "F" ] ; then
		disparity_filter.R -i semantic_matrix_bin -o "./" -O semantic_matrix_bin
		text2binary_matrix.rb -i semantic_matrix_bin -o "filtered_semantic_matrix_bin" -t bin -s > filtered_metrics
		if [ -s filtered_metrics ] ; then 
		awk -v tracker="`cat tracker`" 'BEGIN{FS="\t";OFS="\t"}{gsub(/ - /,"_",$1); gsub(/ /,"_",$0); print tracker,$1,$2}' filtered_metrics >> ../filtered_metrics 
		else
			exit 1
		fi
	fi
}


compare_kernel_[$kernel]){ 
	?
	%calc_kernel_[$nets]){
		# input: Similarity binary matrix
		# output: binary Kernel from similarity matrix + metrics
		source ~soft_bio_267/initializes/init_netanalyzer
		source ~soft_bio_267/initializes/init_ruby
		echo -e "(*)_compare_kernel_(+)\t(*)\tcompare_kernel_(+)" > tracker
		cp !calc_similarity_*!/semantic_matrix_bin.lst kernel_bin.lst # To pass the list of node names.
		kern_net_path=`pwd`
		?
		NetAnalyzer.rb -i !calc_similarity_*!/semantic_matrix_bin -f bin -l 'genes' -k compare_kernel_(+) -n kernel_bin.lst -u 'genes' -K ./kernel_matrix_bin
		text2binary_matrix.rb -i kernel_matrix_bin -o kernel_matrix_undo -t bin -s > kernel_metrics
		if [ -s kernel_matrix_undo ] ; then
			rm kernel_matrix_undo
			awk -v tracker="`cat tracker`" 'BEGIN{FS="\t";OFS="\t"}{gsub(/ - /,"_",$1); gsub(/ /,"_",$0); print tracker,$1,$2}' kernel_metrics >> ../uncomb_kernel_metrics 
			#echo -e "(*)_compare_kernel_(+)\t(*)\t$kern_net_path/kernel_matrix_bin" >> ../kernel_net_tracker 
		else 
	  		exit 1
	  	fi
	}

	%rank_genes_from_uncomb_[$nets]){
		# Input: seed_gens + kernel.
		# Output: rank genes for every gen.
		source ~soft_bio_267/initializes/init_ruby
		echo -e "(*)_compare_kernel_(+)\t(*)\tcompare_kernel_(+)" > tracker
		echo "$backup_gens" > probando
	    genes_iterator=`cat $gens_seed | tr "\n" "\t"`
	    echo "$gens_seed" > prueba
	    for gene in ${genes_iterator} ; do 
			?
			ranker_gene.rb -k !calc_kernel_*!/kernel_matrix_bin -n !calc_kernel_*!/kernel_bin.lst -s "${gene}" -o "${gene}_(*)"
		done
		paths_candidates_file=`echo *_all_candidates | tr " " ","`
		rank_metrics.rb -r $paths_candidates_file -c $backup_gens > rank_metrics
		if [ -s rank_metrics ] ; then
			awk -v tracker="`cat tracker`" 'BEGIN{FS="\t";OFS="\t"}{gsub(/ /,"_",$0); print tracker,$1,$2}' rank_metrics >> ../non_integrated_rank_metrics
		else 
		  	exit 1
		fi
	}

	%integrate_kernel_[$integration_types]){
		# input: kernel matrix from every net.
		# output: A combined binary kernel + metrics. 
		source ~soft_bio_267/initializes/init_ruby
		source ~soft_bio_267/initializes/init_netanalyzer
		# source ~federogc/software/initializes/init_integrate_kernel
		echo -e "(*)_compare_kernel_(+)\t(*)\tcompare_kernel_(+)" > tracker
		integrate_path=`pwd`
		?
		kernel_combined.rb -i (*) -t " !calc_kernel_!/kernel_matrix_bin " -n " !calc_kernel_!/kernel_bin.lst " -o general_matrix 
		text2binary_matrix.rb -i general_matrix -o general_matrix_undo -t bin -s > generalkernel_metrics
		if [ -s general_matrix_undo ] ; then
			rm general_matrix_undo
			# Now we prepare to create_metric_table.rb
			awk -v tracker="`cat tracker`" 'BEGIN{FS="\t";OFS="\t"}{gsub(/ - /,"_",$1); gsub(/ /,"_",$0); print tracker,$1,$2}' generalkernel_metrics >> ../comb_kernel_metrics 
			# Now we need to save the path of the integrated matrix.
			# echo -e "(*)_compare_kernel_(+)\t$integrate_path/general_matrix" >> ../integrate_tracker 
		else 
	  		exit 1
	  	fi
	}

	%rank_genes_from_integrated_[$integration_types]){
		# Input: seed_gens + kernel.
		# Output: rank genes for every gen.
		source ~soft_bio_267/initializes/init_ruby
		echo -e "(*)_compare_kernel_(+)\t(*)\tcompare_kernel_(+)" > tracker
	    genes_iterator=`cat $gens_seed | tr "\n" "\t"`
	    for gene in ${genes_iterator} ; do 
			?
			ranker_gene.rb -k !integrate_kernel_*!/general_matrix -n !integrate_kernel_*!/general_matrix.lst -s "${gene}" -o "${gene}_(*)"
		done
		rank_metrics.rb -r *_all_candidates -c $backup_gens > rank_metrics
		if [ -s rank_metrics ] ; then
			awk -v tracker="`cat tracker`" 'BEGIN{FS="\t";OFS="\t"}{gsub(/ /,"_",$0); print tracker,$1,$2}' rank_metrics >> ../integrated_rank_metrics
		else 
		  	exit 1
		fi
	}

}


corr_non_integrated_kernels_[$nets]){
	source ~soft_bio_267/initializes/init_R
	all_paths=`echo -e "!calc_similarity_*!/semantic_matrix_bin !calc_kernel_*!/kernel_matrix_bin" | tr " " ","`
	all_names=`cat !calc_similarity_*!/tracker !calc_kernel_*!/tracker | cut -f1 | tr "\n" ","`
	all_names=${all_names::-1}
	corr_method='spearman' 
	?
	correlate_matrices.R -d $all_paths -m $corr_method -o "." -n $all_names -O non_integrated_(*)_"$corr_method"_correlation
	if [ ! -s non_integrated_(*)_"$corr_method"_correlation.png ] ; then
		exit 1
	fi 
}

corr_integrated_kernels){
	source ~soft_bio_267/initializes/init_R
	all_paths=`echo -e "!integrate_kernel_!/general_matrix " | tr " " ","`
	all_paths=${all_paths::-1}
	all_names=`cat !integrate_kernel_!/tracker | cut -f1 | tr "\n" ","`
	all_names=${all_names::-1}
	corr_method='spearman' 
	?
	correlate_matrices.R -d $all_paths  -m $corr_method -o "." -n $all_names -O integrated_kern_correlation
	if [ ! -s integrated_kern_correlation.png ] ; then
		exit 1
	fi 
}


#%link_2_kernels){
#	paths=" !integrate_kernel_!/general_matrix !calc_kernel_!/kernel_matrix_bin "
#	for path in $paths ; do # Esta no es la forma corecta. Preguntar a Pedro.
#		?
#		ln -s "$path"
#	done
#}

#rank_genes_from_integr){
#	# Input: seed_gens + kernel.
#	# Output: rank genes for every gen.
#	source ~soft_bio_267/initializes/init_ruby
#    mkdir -p ../../report/candidates/integrated_kernels/compare_kernel_(+) 
#    #affected_genes=`wc -l $gens_seed`
#	?
#	ranker_genes.rb -k !integrate_kernel_*!/general_matrix -n !integrate_kernel_*!/general_matrix.lst -s $gens_seed # TODO: check the iteration part!
#	#cp *_candidates ../../report/candidates/integrated_kernels/compare_kernel_(+)
#	count_candidate_files=`ls | grep -c _candidates`
#	if [ $count_candidate_files -ge 1 ] ; then
#		cp *_possible_candidates ../../report/candidates/integrated_kernels/compare_kernel_(+)
#	else 
#  		exit 1
#  	fi
#}